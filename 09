九、合约abi规则说明文档
基本设计
在以太坊系统中，合约二进制接口abi是与合约交互的标准，无论是通过链外部调用合约，还是合约间的相互调用。数据根据自身类型，被编码成特定规格。这种编码不具备语义化自述的能力，所以需要一张表来做解码。
我们假设合约的接口方法是强类型，在编译时是静态且已知的。我们假设所有智能合约在编译时已知他们能调用的合约的任何接口的接口定义。
这个标准不适用于动态接口，或者那些在运行时才能确定的合约地址。
函数选择器
在所调用的函数的标准显示里面，前四个字节是通过Keccak-256（SHA-3）hash签名算法，计算所调用的函数名得到的。这个签名来自官方的基本类型的表达式，没有本地数据规格。像函数的方法名和括号里面的参数类型。参数类型通过”,”分割，中间没空格。

注释：方法的返回类型不属于签名部分。在solidity的方法重载返回的类型是不被考虑的。原因是为了保持调用方法的上下文独立。 然而JSON格式对abi的描述，是包含输入和输出格式的。

参数编码
从第五个字节开始，后面的都是参数编码后的内容。这些编码方式也用在其他地方，像返回值和事件参数，不过就没有函数的前四个特殊字节。

类型
下面节本类型参数存在：
uint<M>：无符号的M位整型。其中：0<M<=256,M%8==0。如：uint32、uint8、uint256。
int<M>: 二进制有符号的M位的整型。其中：0<M<=256, M%8==0。
address：等同于uint160 , 除了假设解释和语言类型。address也被用在函数选择上。
uint，int：uint256和int256的同义词，计算所选择的函数的时候用。
bool：等同于uint8，严格限定其值是0和1，计算所选择的函数的时候用。
fixed<M>x<N>：有符号固定小数位是M位，8<=M<=256,M%8==0,并且 0<N<=80,这意味着v的值同 v/(10 **N)相等。
ufixed<M>x<N>：无符号的变量fixed<M>x<N>
fixed,ufixed： fixed128*18和ufixed128*18各自的的同义词。函数选择器里面使用。
bytes<M>: 二进制类型M位，0<M<=32
function: （20个字节）的地址后面跟函数选择（4个字节）。编码同bytes24一样。

固定大小的给定类型数组
<type>[M]:固定大小的数组，填充M个给定类型的元素Type

非固定大小的类型：
bytes：动态大小的字节序列
string：动态大小的unicode字串，编码成utf8类型
<type>[]:一个填充给定元素的可变长度字串

不同的类型们，也可以通过括号合并为元组，内部通过逗号隔开。
(T1,T2,T3......Tn):其中的tuple由给定类型组成的T1,......Tn， n>=0
也可以从tuples形成tuples， tuples形成数组等等。也可以有大小为0的tuples

Mapping在solidity中对应的abi类型
Solidity支持上面展示的所有同名和以tuple处理异常的类型。也就是说，一些solidity的类型是不被abi接口支持的。下表中，左列solidity的类型不是abi类型，右列的类型在abi中表示他们。


设计编码规则
设计编码规范是为了让有如下的属性，尤其是一些参数有嵌套数组时非常有用：
1、标明的数字能说明对应值的内部参数的最大深度。如:a_i[k][l][r]中标识出4。在早先ABI的版本中，线性标明的数字是动态参数的最坏情况。
2、变量数据或者数组元素不交叉和其他数据，而且是可定位的，例如，只用相关的”addresses”。

正式的编码规格
我们需区分静态类型和动态类型，静态类型是编译时保持原状， 动态类型是当前区块之后分割位分开。
定义：下面类型称为动态：
bytes
string
T[]       for any T
T[k]      for any dynamic T and any k>=0
(T1,...,Tk)  if Ti is dynamic for some 1 <= i <= k

其他所有类型的称为静态类型。

定义：len（a）表示二进制字符串a的字节长度数，返回值类型是uint256
定义enc，实际的编码方式，像abi类型的映射值到二进制字串，方法len（enc（x））依赖于x的值，其中x是动态类型，并且只有x是动态类型的。
定义：对任何x值的abi，任何迭代enc（x）的方法，都依赖于x的类型
* (T1,...,Tk)对于k>=0 的任何类型T1, …, Tk。 	enc(X) = head(X(1)) ... head(X(k)) tail(X(1)) ...tail(X(k))，
其中的X = (X(1), ..., X(k))，根据Ti定义的head和tail, 连同head(X(i)) = enc(X(i)) 和tail(X(i)) = ""（空字串），还有像head(X(i)) = enc(len(head(X(1)) ... head(X(k)) tail(X(1)) ... tail(X(i-1)) ))tail(X(i)) = enc(X(i))，这些都属静态类型。
否则的话，Ti就是动态类型。

注释：在动态类型的例子，head(X(i))从数据头部长度开始定义，定义时只依赖于类型而不是值。值tail(X(i))在开头处对应的偏移量，跟enc(X)相关。

T[k]：任意填入T 和K：
enc(X) = enc((X[0], ..., X[k-1]))
即：有k个相同类型元素编译的tuple
T[]：
x有k个元素（k假定是uint256类型）：
enc(X) = enc(k) enc([X[0], ..., X[k-1]])
即：大小为k的静态数组，前缀是元素的个数。
bytes，长度为k（类型为uint256）：
enc(X) = enc(k)pad_right(X),即：字节个数被编码成uint256，后面跟着真实值x的字节序列，后面接最小零字节len(enc(X))，来自是32的乘积。
string:  enc(X) = enc(enc_utf8(X))，即：x是utf-8编码的，并且它的来自对bytes字节的翻译解释。
注释：长度是指在编码的的字符串string，而不是characters。
uint<M>: enc(X)是大端编码x，用零在高位（左边）补足长度到32字节。
address: 同uint160。
int<M>: enc(X)大端二进制对X进行编码，在高位（左边）补足长度到32字节，用0xff补足。
bool:同uint8,1为true，0是false。
fixed<M>x<N>: enc(X) 等同于enc(X * 10**N)，此处X * 10**N可以翻译成int256。
fixed:等同于fixed128x18
ufixed<M>x<N>: enc(X)等同于enc(X * 10**N)，此处X * 10**N可以翻译成uint256。
ufixed: 等同于ufixed128x18
bytes<M>: enc(X)就是字节码序列，x的尾部补零补足到32字节。
注释：对于任意X ，len(enc(X))都是32的乘积。

方法选择器和参数编码
总之，用参数a_1, ..., a_n调用方法f，会被编译成function_selector(f) enc((a_1, ..., a_n))
并且，函数f的返回值被编译成enc((v_1, ..., v_k))
即：结果值被编译成tuple类型。

示例
合约示例

如上的Foo合约，如果我们想用参数69和true来调用baz方法，我们总共需要68个字节，可被细分成：
0xcdcd77c0：方法标识id，这是是根据方法名baz（uint32，bool）通过Keccak hash的方法得到的前四个字节。
0x0000000000000000000000000000000000000000000000000000000000000045：第一个参数，69通过uint32位字节的表示方式。
0x0000000000000000000000000000000000000000000000000000000000000001：第二个参数，true用32位标识表示方式。
合起来的表示：
0xcdcd77c000000000000000000000000000000000000000000000000000000000000000450000000000000000000000000000000000000000000000000000000000000001
方法返回值是一个bool类型。举例来说，返回false的时候，输出将是一个单字节数组
0x0000000000000000000000000000000000000000000000000000000000000000。

如果用参数[“abc”,”def”]调用bar方法，我们总共需要68个字节，分解来看：
0xfce353f6：方法标识id，根据方法bar（bytes3[2]）提取出来的。
0x6162630000000000000000000000000000000000000000000000000000000000：参数第一部分，参数“abc”的bytes3的值。
0x6465660000000000000000000000000000000000000000000000000000000000：参数第二部分，参数“def”的bytes3的值。
合起来表示：
0xfce353f661626300000000000000000000000000000000000000000000000000000000006465660000000000000000000000000000000000000000000000000000000000

如果通过“dave”，true和[1,2,3]作为参数来调用sam方法，我们需要292个字节，分解来看：
0xa5643bf2：方法标识id，根据方法sam(bytes,bool,uint256[])签名得到的。注释：uint 被替代通过官方的uint256.
0x0000000000000000000000000000000000000000000000000000000000000060：第一个参数的一部分，动态类型。
0x0000000000000000000000000000000000000000000000000000000000000001：第二个参数，true
0x00000000000000000000000000000000000000000000000000000000000000a0：第三个参数的一部分，动态类型。
0x0000000000000000000000000000000000000000000000000000000000000004：第一个参数，以byteArray的长度开头，这里就是4。
0x6461766500000000000000000000000000000000000000000000000000000000：“dave”的编码。
0x0000000000000000000000000000000000000000000000000000000000000003：参数的第三部分，以元素的长度开头，这儿就是3。
0x0000000000000000000000000000000000000000000000000000000000000001:第三个参数的第一个元素
0x0000000000000000000000000000000000000000000000000000000000000002:第三个参数的第二个元素
0x0000000000000000000000000000000000000000000000000000000000000003:第三个参数的第三个元素
合起来标识：
0xa5643bf20000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000a0000000000000000000000000000000000000000000000000000000000000000464617665000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000003000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000003

用动态类型做参数
传入参数（0x123，[0x456,0x789],”1234567890”,”Hello,world”），来调用方法f(uint,uint32[],bytes10,bytes)，其中编码步骤如下：
先取方法sha3("f(uint256,uint32[],bytes10,bytes)")的前四个字节标识,即:0x8be65246。接下来编译头部分的前四个参数。对于静态类型uint256和bytes10，我们直接取值编译就可以，然而动态类型的uint32[]和bytes，我们需从开始值的开头处进行计算数据的偏移位。（即，不计算开头的四个字节）
0x0000000000000000000000000000000000000000000000000000000000000123（0x123用32字节标识）
0x0000000000000000000000000000000000000000000000000000000000000080（从偏移位开始，第二个参数的部分，4*32个字节，头部分数据大小的精确值）
0x3132333435363738393000000000000000000000000000000000000000000000（“123456789”补零到右面，形成32个字节）
0x00000000000000000000000000000000000000000000000000000000000000e0（数据开头处的四个参数=数据开头处动态参数+第一个动态数据参数大小 = 4*32 + 3*32（值来源于下面））
再看后面的动态参数，[0x456,0x789]如下：
0x0000000000000000000000000000000000000000000000000000000000000002（数组元素个数，2）
0x0000000000000000000000000000000000000000000000000000000000000456(第一个元素)
0x0000000000000000000000000000000000000000000000000000000000000789(第二个元素)
最后，编译第二个动态参数，“hello world!”：
0x000000000000000000000000000000000000000000000000000000000000000d（元素bytes个数:13） 
0x48656c6c6f2c20776f726c642100000000000000000000000000000000000000（“hello，world！”右补位到32位） 
合起来看，编码结果如下所示（32位进行折行，是为了方便看而已）:
0x8be65246
  0000000000000000000000000000000000000000000000000000000000000123    //0x123
  0000000000000000000000000000000000000000000000000000000000000080    //4*32
  3132333435363738393000000000000000000000000000000000000000000000    //”1234567890”
  00000000000000000000000000000000000000000000000000000000000000e0    //4*32+3*32
  0000000000000000000000000000000000000000000000000000000000000002    //array,2
  0000000000000000000000000000000000000000000000000000000000000456    //456
  0000000000000000000000000000000000000000000000000000000000000789    //789
  000000000000000000000000000000000000000000000000000000000000000d    //13
  48656c6c6f2c20776f726c642100000000000000000000000000000000000000    //hello,world!

相同的规则用到编码方法g（uint[][],string[]）上,参数带（[[1,2],[3]],[“one”,”two”,”three”]），开始从最原子的部分编码：
首先，编译数据长度和 第一个插入的动态数组[[1,2],[3]]的第一个元素[1,2]:
0x0000000000000000000000000000000000000000000000000000000000000002:（第一个数组元素的个数2，包括的元素1和2）
0x0000000000000000000000000000000000000000000000000000000000000001：第一个元素
0x0000000000000000000000000000000000000000000000000000000000000002：第二个元素
接下来编译数据长度和动态数组中第二个元素:
0x0000000000000000000000000000000000000000000000000000000000000001:第二个数组元素个数1，其中元素是3
0x0000000000000000000000000000000000000000000000000000000000000003:第一个元素3

接下来，我们需要找a和b各自的动态数组[1,2]和[3]。为了计算队列，先计算根数组的第一个编译元素[[1,2],3],列出每行编码结果：
0-a                                                                      - offset of [1, 2]
1-b                                                                      - offset of [3]
2-0000000000000000000000000000000000000000000000000000000000000002 - count for [1, 2]
3-0000000000000000000000000000000000000000000000000000000000000001 - encoding of 1
4-0000000000000000000000000000000000000000000000000000000000000002 - encoding of 2
5-0000000000000000000000000000000000000000000000000000000000000001 - count for [3]
6-0000000000000000000000000000000000000000000000000000000000000003 - encoding of 3
偏移量a指向数组内容[1,2]的开头，在第二行64个字节，因此：
a = 0x0000000000000000000000000000000000000000000000000000000000000040.
偏移量b指向数组内容[3]的开头，在第五行用160个字节，因此：
b = 0x00000000000000000000000000000000000000000000000000000000000000a0.

然后，编译跟元素中第二个元素的内容
0x0000000000000000000000000000000000000000000000000000000000000003（第一个参数“one”的个数）
0x6f6e650000000000000000000000000000000000000000000000000000000000（以utf8的格式表示“one”）
0x0000000000000000000000000000000000000000000000000000000000000003(第二个参数“two”的个数)
0x74776f0000000000000000000000000000000000000000000000000000000000（以utf8的格式表示“two”）
0x0000000000000000000000000000000000000000000000000000000000000005（第三个参数“three”的个数）
0x7468726565000000000000000000000000000000000000000000000000000000（以utf8的格式表示“three”）
类型于第一个根元素的数组，动态字符串们的相应偏移量c，d和e：
0 - c                                                                - offset for "one"
1 - d                                                                - offset for "two"
2 - e                                                                - offset for "three"
3 - 0000000000000000000000000000000000000000000000000000000000000003 - count for "one"
4 - 6f6e650000000000000000000000000000000000000000000000000000000000 - encoding of "one"
5 - 0000000000000000000000000000000000000000000000000000000000000003 - count for "two"
6 - 74776f0000000000000000000000000000000000000000000000000000000000 - encoding of "two"
7 - 0000000000000000000000000000000000000000000000000000000000000005 - count for "three"
8 - 7468726565000000000000000000000000000000000000000000000000000000 - encoding of "three"
标识符c指向第三行字串“one”，	c = 0x0000000000000000000000000000000000000000000000000000000000000060
标识符d指向第五行字串“two”，
d = 0x00000000000000000000000000000000000000000000000000000000000000a0
标识符e指向第七行字串“three”，
e = 0x00000000000000000000000000000000000000000000000000000000000000e0
注释：函数中根元素数组元素不相互依赖

接着编译第一个根元素长度：
0x0000000000000000000000000000000000000000000000000000000000000002（根元素中数组个数是2，其中元素分别是[1,2],和[3]）
接着第二个根元素长度：
0x0000000000000000000000000000000000000000000000000000000000000003（根元素中数组元素个数3，其中元素是“one”，“two”和“three”）
最后，f和g分别是动态数组[[1,2],[3]]和[“one”,”two”,”three”]各自的偏移量，相关排序如下：

事件Events
事件是以太坊log和事件交互时的一个抽象。日志log入口提供合约地址，一系列长度和四个主题随机二进制数据。事件影响存在的函数abi是为了解释 为一个接口的规则，作一个合适的类型结构。
给出一个事件名和一些类事件参数，我们分割他们成两个子序列：包含下标序列的和不标序列的。这些标出下标序列的，可能有3，被边缘化事件签名log入口。没下标的形成集合事件。
事实上，log入口使用abi的描述如下：
address:合约地址（以太坊提供）
topics[0]:keccak(EVENT_NAME+"("+EVENT_ARGS.map(canonical_type_of).join(",")+")")  (canonical_type_of  这个函数会返回官方推荐的类型。如：uint index foo,将返回 uint256）。如果事件被声明成匿名的，topics[0]不被生成。
topics[n]: EVENT_INDEXED_ARGS[n - 1] （EVENT_INDEXED_ARGS是EVENT_ARGS系列的下标）
data: abi_serialise(EVENT_NON_INDEXED_ARGS)(EVENT_NON_INDEXED_ARGS 是EVENT_ARGS没下标的序列，abi_serialise是ABI序列化函数，像上面描述的，被用来从函数来返回函数一些列类型)
对于所有固定长度的Solidity类型，EVENT_INDEXED_ARGS数组直接包含32字节编码值。然而，对于动态类型的长度，包括像string，bytes和arrays，EVENT_INDEXED_ARGS将包含Keccak hash编译后的值，而不是直接存入值。 这样允许应用高效的查询动态数据类型长度（通过设置编码值的hash值作为topic），但应用不能解码下标值他们没有查询的。对于动态数组类型，应用开发者面对一个交易在快速搜索预定值（如果参数带下标）和易辨认的随机数（这个参数没下标）。开发者可能处理这个交易，并且实现高效搜索和用两个参数随机定义事件-有下标和没下标，保持同一个值。
Json
Json格式对合约接口来说是通过一些列函数或者事件描述。 函数描述一个json对象包含下面属性：
type: "function", "constructor", or "fallback"（未命名的默认 function）
name:函数名
inputs:一个数组对象，每个包含如下：
name:参数名
type: 官方参数类型
components: 用作元组tuple类型
outputs: 一个类似inputs的数组对象，可被抛出，如果函数没返回任何东西。
stateMutability:字串包含下面的值：pure（不用读取链状态），view（修改链状态），nopayable（方法接受以太币），payable（方法消耗以太币）；
payable: 为true，方法接受以太币 ，false反之。
constant: 为true，方法是pure或者view，反之是false。
type可以被抛出，默认function，像payable和constant可以被抛出，两个默认都是false。

构造器和回调方法没有name或者outputs，同时回调方法也没有inputs。

警告：constant和payable方法已标位过期，stateMutability 属性可以定义相同属性。
注释：调用不用支付的函数时，发送非零ether的参数，会重置这个交易。

事件描述和JSON对象描述有着相同的属性：
type:总是"event"
name:事件名称
inputs:对象的数组集合，每个包含如下：
name: 参数名称
type: 官方推荐的参数类型。
components: 元组类型tuple使用
indexed: 如果属性是log topics的一部分，为true。如果不是log数据的一部分，为false。
anonymous:如果事件被定义成anonymous，为true。
示例：


转成JSON类型后：

处理tuple类型
尽管命名没有在ABI编码中，但是对于终端用户来说有这重要的意义。结构类型是嵌套的如下所示：
一个有着name，type和潜在components描述一个类时可变的。在元组tuple和字符串用tuple前缀存储，描述到达后，会转成官方推荐的类型。如：一些列[]和[k]最终会被转成tuple。 Tuple组件们最终会被存储在 components里面， 这是一个有着相同数据结构和顶级对象，indexed 不允许。
示例代码如下：

转成Json会是：

严格编码模式
严格编码模式是精确使用上面说的正式编码格式。也就是说偏差要尽可能小，同时在数据区域没有数据重叠，能够无缝交互。
通常，ABI解码时候，根据偏移指针直接进行解码，但一些解码器可能会强迫使用严格模式。Solidity ABI解码器现在不强迫使用严格模式，但是编码常常是在严格模式下进行的。

非标准打包模式
通过abi.encodePacked(), Solidity支持非标准的打包模式：
类型少于32位，0补位并且扩展
动态类型被原状编码，并且不包含长度
举例如下：int8、bytes1、uint16、string的对应值-1、0x42、0x2424、“hello,world!” 被编译成：

每个静态大小类型在其范围内，占尽可能多的位数，动态类型像string、bytes或者uint[]被编码时，没有了他的长度属性。这导致一旦有两个动态类型的元素，可能会产生歧义。
如果缩进被加入，确切的类型能被使用：
abi.encodePacked(uint16(0x12)) == hex"0012"
由于编码打包没被用在函数调用上，





动态类型的使用


事件


JSON


Tuple类型处理


严格限定的编码格式

非标准打包模式
